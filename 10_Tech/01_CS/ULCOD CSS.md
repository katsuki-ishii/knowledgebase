---
base: "[[CS.base]]"
作成者: Katsubo Katsubo
カテゴリー:
  - CS
作成日時: 2026-01-09T01:24:00
aliases: [ULCOD CSS, ULCOD, ulcod, CSS]
---
# [[REST 概要|REST]]の6つのスタイル（[[ULCOD CSS]]）まとめ

[[REST 概要|REST]]（Representational State Transfer）は、HTTP APIの書き方ではなく、**分散システムを長期的にスケールさせるための設計思想**である。

本質は「サーバが管理するリソースの状態を、表現（Representation）を通じて遷移させる」ことにある。

以下では、これまでの理解を踏まえ、[[REST 概要|REST]]を構成する6つのスタイルを**思想 → 意味 → 具体例**の順で整理する。

---

## [[REST 概要|REST]]の全体像（図解）

```plain text
[ Client ]
    |
    |  HTTP (URI + Method + Representation)
    v
[ Intermediaries ]  (Cache / Proxy / LB)
    |
    v
[ Server ] ---- manages ----> [ Resource (State) ]

```

[[REST 概要|REST]]は、クライアントとサーバの間に存在する**中間層が通信の意味を理解できる**ことを重視する。

---

## 1. Uniform Interface（統一インターフェース）

### 思想（なぜ必要か）

Uniform Interfaceは、[[REST 概要|REST]]における最重要スタイルであり、他のスタイルを成立させる前提条件である。

Webが巨大化しても破綻しなかった理由は、**すべてのリソース操作が共通のルールで行われた**点にある。

「このAPI専用の使い方」を排除し、**HTTPという共通言語だけで意味が通じる**状態を目指す。

### 要点

- [[URI・URL・URN|URI]]はリソース（名詞）を表す
- HTTPメソッドは状態遷移の種類を表す
- 表現（[[設定ファイル言語|JSON]]など）は現在または次の状態を表す

### 具体例

```plain text
GET    /users/123        ユーザーの現在の状態を取得
PUT    /users/123        ユーザーの状態を完全に置き換える
PATCH  /users/123        ユーザーの一部状態を変更
DELETE /users/123        ユーザーを削除状態にする

```

### なぜ重要か

- 中間層（キャッシュ・プロキシ）が意味を理解できる
- APIごとに学習コストが増えない
- 冪等性や安全性をHTTPに委譲できる

### 破りがちな例

```plain text
POST /getUser
POST /updateUser

```

これはHTTPを単なるトンネルとして使っており、[[REST 概要|REST]]の利点を失う。

---

## 2. Layered System（階層化システム）

### 思想（なぜ必要か）

Layered Systemは、Webが**中央集権的に管理されていない世界**で成立するための前提である。

クライアントは「誰が最終的に処理しているか」を知らない。

### 要点

- 通信経路の途中に任意の層を挟める
- 各層は独立した責務を持つ
- 上位層は下位層の存在を意識しない

### 図解

```plain text
Client
  ↓
CDN（Cache）
  ↓
Proxy / API Gateway
  ↓
Application Server

```

### 具体例

- CDNがGETレスポンスをキャッシュ
- ロードバランサがリクエストを分散
- API Gatewayが認証・制限を担当

### なぜ重要か

- スケール戦略を後付けできる
- セキュリティや最適化を独立して強化できる

---

## 3. Client / Server（クライアント・サーバ分離）

### 思想（なぜ必要か）

Client / Server 分離は、[[REST 概要|REST]]が「単一アプリケーション」ではなく、**長期間・多様な利用者に耐える基盤**であるための前提条件である。

UIとデータ管理を分離することで、どちらか一方の変更が他方を壊さない構造を作る。

これは単なる役割分担ではなく、**進化速度の異なるものを分離する設計判断**である。

### 要点

- クライアントは表示・入力・UXに責務を限定
- サーバはリソースとその状態遷移のみを管理
- 双方はHTTPという契約だけで結合

### 図解

```plain text
[ Client ]  UI / 操作
     |
     | HTTP
     v
[ Server ]  Resource / State

```

### 具体例

- 同一の `/users` API を
    - Web管理画面
    - モバイルアプリ
    - バッチ処理
が同時に利用

### なぜ重要か

- フロントエンド刷新時にAPIを作り直さなくてよい
- クライアント追加（新チャネル）に強い
- サーバ実装を段階的に置き換えられる

---

## 4. Cache（キャッシュ）

### 思想（なぜ必要か）

Cacheは、[[REST 概要|REST]]が**ネットワーク越しで遅く不安定な通信**を前提としていることから生まれたスタイルである。

「サーバは常に最新情報を返す存在」という前提を捨て、**十分新しい状態であれば再利用してよい**とする。

### 要点

- キャッシュ可能かどうかを明示する
- 鮮度と再検証ルールをHTTPで表現

### 図解

```plain text
Client
  ↓
Cache（CDN / Browser）
  ↓
Server

```

### 具体例

```plain text
GET /users/123
Cache-Control: max-age=600
ETag: "v1"

```

```plain text
If-None-Match: "v1"  → 304 Not Modified

```

### なぜ重要か

- サーバ負荷を指数関数的に下げられる
- 中間層が自律的に通信を最適化できる
- Webが巨大トラフィックを扱える理由

---

## 5. Stateless Server（ステートレス）

### 思想（なぜ必要か）

Stateless Serverは、[[REST 概要|REST]]が**サーバ増減を前提とした設計**であることを示す。

サーバがクライアントの文脈を保持すると、分散配置が困難になる。

[[REST 概要|REST]]では、状態はすべてリソースに集約され、サーバは単なる処理装置となる。

### 要点

- サーバはセッション状態を持たない
- 認証・権限情報は毎回送信

### 図解

```plain text
Request A → Server 1
Request B → Server 2
(どちらでも同じ結果)

```

### 具体例

```plain text
Authorization: Bearer <JWT>

```

### なぜ重要か

- ロードバランサと完全に相性が良い
- 障害時の切り替えが容易
- 冪等な再試行が可能

---

## 6. Code on Demand（任意）

### 思想（なぜ存在するか）

Code on Demandは、[[REST 概要|REST]]の中で唯一、**クライアントの単純性を犠牲にして柔軟性を得るスタイル**である。

サーバは、必要に応じてクライアントに新しい振る舞いを配布できる。

### 要点

- コード（JS / WASM）を配布
- クライアントがそれを実行

### 図解

```plain text
Server → JavaScript → Client

```

### 具体例

```plain text
<script src="/app.js"></script>

```

### なぜ任意か

- クライアント実装が複雑になる
- セキュリティ上の制約が増える
- [[REST 概要|REST]]のスケーラビリティ本質には寄与しない

---

## [[REST 概要|REST]]の核心思想（総まとめ）

[[REST 概要|REST]]の本質は以下に集約される。

- サーバはリソース（状態）を管理する
- クライアントは命令ではなく状態を送る
- 通信はHTTP標準の意味に従う
- 中間層が内容を知らなくても最適化できる

### 一文で表すと

[[REST 概要|REST]]とは、

- *「サーバの状態機械を、HTTPという共通言語で安全に操作するための設計思想」**である。

## 関連
- [[REST 概要]]
