---
base: "[[CS.base]]"
作成者: Katsubo Katsubo
カテゴリー:
  - CS
作成日時: 2025-08-06T00:35:00
aliases: [Web Socket, WebSocket, Web socket, websocket]
---
# 1. [[Web Socket|WebSocket]]とは

- ブラウザやアプリとサーバー間で「双方向かつ常時接続」の通信を可能にするプロトコル。
- HTTPのような「リクエスト→レスポンス型」ではなく、接続後はサーバーからクライアントへも随時データを送信できる。

## 2. なぜ必要になったのか（歴史・背景）

- 従来のHTTPではリアルタイム性が求められるサービス（チャット、ゲーム、株価通知など）で限界があった。
- 以前は「ポーリング」や「Long Polling」などの手法で疑似的に実現していたが、効率が悪く遅延や負荷の問題が大きかった。
- 2008年頃から[[Web Socket|WebSocket]]の必要性が議論され、2011年に[[RFC]] 6455として正式に標準化。

## 3. [[Web Socket|WebSocket]]の仕組み

- 最初だけHTTPリクエスト（Upgradeヘッダ付き）で接続要求を出す。
- サーバーが「101 Switching Protocols」で応答し、[[Web Socket|WebSocket]]通信が確立。
- 以降はTCPソケットを使い、クライアント・サーバー間で双方向に任意のタイミングでデータ送受信できる。

## 4. HTTPとの違い

| 項目 | HTTP | [[Web Socket|WebSocket]] |
| --- | --- | --- |
| 通信モデル | 一方向、都度接続・切断 | 双方向、常時接続 |
| サーバーからの通知 | 不可（クライアントがリクエスト） | 可能（サーバーからPush） |
| リアルタイム性 | ポーリング等で工夫が必要 | ミリ秒単位の即時通知 |

## 5. 実際の用途例

- LINEやSlackなどのチャットアプリの「既読通知」や「入力中表示」
- ゲームの状態同期
- 株価やセンサーのライブデータ配信
- ブラウザ上の協働編集など

## 6. 典型的な通知フロー（既読通知の場合）

1. Bがメッセージを開く（既読）
2. Bが[[Web Socket|WebSocket]]でサーバーに「既読」と送信
3. サーバーがAとの接続を通じてAに「既読通知」をPush
4. Aの画面が即時更新

## 7. [[Web Socket|WebSocket]]の通信管理

- [[Web Socket|WebSocket]]接続はサーバー側で「誰がどのソケットに接続しているか」を常時保持
- Ping/Pong（プロトコルレベルのヘルスチェック）で接続の死活を管理
- 複数クライアントの常時接続状態をサーバーで仲介・管理するのがリアルタイム通信の鍵

## 8. [[Web Socket|WebSocket]]のスケーラビリティ課題

- 大規模サービスではサーバーのメモリやソケット、ファイルディスクリプタなどリソース管理が課題になる
- 冗長化時は「Sticky Session」（同じサーバーへの接続維持）が必要
- 状態共有のためのRedisやPub/Subなどの仕組みがよく使われる
- サーバーレス（例：AWS Lambda）との相性は悪い（常時接続・状態保持ができないため）

## 9. 主要な関連技術と比較

| 技術 | 概要 | 主な用途 |
| --- | --- | --- |
| HTTP | 一方向、都度接続、リアルタイム性は低い | [[REST 概要|REST]] API |
| [[Web Socket|WebSocket]] | 双方向・常時接続で即時性が高い | チャット、通知など |
| SSE | サーバー→クライアントの一方向Push、簡単 | 通知、ライブ更新 |
| Push通知 | OSやブラウザが受け取るリアルタイム通知 | アプリ非アクティブ時 |
| Webhook | サーバー→サーバーの通知、クライアント不可 | 外部サービス連携 |

## 11. HTTPと[[Web Socket|WebSocket]]の通信方式の違い・設計方法

### 1. [[Web Socket|WebSocket]]にはHTTPメソッドがない

- [[Web Socket|WebSocket]]では「GET」「POST」などのHTTPメソッドが存在しない。
- 通信の中身は「バイト列（テキストまたはバイナリ）」のみで、やり取りする内容の意味付けはアプリケーション独自で設計する。

### 2. データやりとりの具体例

- 例：チャットアプリのメッセージ送信
```json
{ "type": "message", "text": "こんにちは" }

```
- 例：既読通知
```json
{ "type": "read", "messageId": "abc123" }

```
- この "[[基礎 Part 36 props バリデーション|type]]" のようなフィールドで通信の目的を区別し、アプリケーションが「どの処理か」を判定する。
- HTTPでのメソッドに相当するのが、[[Web Socket|WebSocket]]ではアプリケーション独自の[[基礎 Part 36 props バリデーション|type]]設計。

### 3. サーバー側の受信・判別の仕組み

（Node.jsの例）

```javascript
ws.on('message', (data) => {
  const msg = JSON.parse(data);

  if (msg.type === "message") {
    // メッセージ送信処理
  } else if (msg.type === "read") {
    // 既読通知処理
  }
});

```

### 4. 比較表まとめ

|   | HTTP | [[Web Socket|WebSocket]] |
| --- | --- | --- |
| 通信の区別方法 | メソッド(GET/POST等) | データ内容で区別（[[基礎 Part 36 props バリデーション|type]]等で自作） |
| 仕様の標準化 | [[RFC]]で厳密に決まってる | アプリごとに「プロトコル」を設計 |
| 柔軟性 | 決まった用途だけ | なんでも自由に（ただし実装必要） |

### ポイント

- [[Web Socket|WebSocket]]では「どんな操作か」の意味づけを自作のプロトコル設計で実現する。
- 通信内容の拡張や新機能追加も柔軟にできる反面、設計やテストの責任は実装者側にある。

## 関連
- [[Vite HMR]]
- [[イベント駆動と時間駆動]]
