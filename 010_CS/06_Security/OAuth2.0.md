---
base: "[[CS.Security.base]]"
作成者: Katsubo Katsubo
カテゴリー:
  - CS
作成日時: 2026-02-09T12:00:00
aliases: [OAuth, oauth, OAuth2, OAuth 2.0]
---

# [[OAuth|OAuth 2.0]]

## 1. なぜ[[OAuth2.0|OAuth]]が必要になったのか

### 登場人物は必ず3者になる

```
[ユーザー]
    |
    |  (自分のデータを使わせたい)
    |
[サービス本体] —— [第三者アプリ]
 (Google等)        (外部アプリ)
```

- ユーザー：データとアカウントの最終的な所有者。
- サービス本体：ID/パスワードを管理し、データの生殺与奪権を持つ主体。
  - 具体例：Google（Googleアカウント・Gmail・Google Drive）／Twitter（X）（ツイート・DM）／GitHub（リポジトリ・Issue）。
  - 特徴：ユーザー本人確認を行い、トークンを発行する唯一の存在。
- 第三者アプリ：本体ではないが、ユーザーの代わりに操作したい存在。
  - 具体例：Notion連携ツール／Slack Bot／Twitterクライアントアプリ／Zapier・Power Automate。
  - 特徴：パスワードは一切知らず、[[OAuth]]で発行されたトークンのみを使って操作する。

重要なのは、**ユーザー自身は直接APIを叩かない**という点である。実際に操作するのは常に「アプリ」であり、[[OAuth]]はこの代理関係を安全に成立させるための仕組みである。

---

### [[OAuth2.0|OAuth]]以前の世界で何が起きていたか

```
[ユーザー]
   ↓ ID/Password
[第三者アプリ]
   ↓ なりすましログイン
[サービス本体]
```

この構造では、第三者アプリは「ユーザー本人」と[[ITと不完全さに惹かれる理由|完全]]に同一視される。

- サービス本体から見れば、操作主体を区別できない。
- 第三者アプリは全権限を持つ。
- 権限という概念が存在しない。

ID/パスワードは以下のような場所に保存されていた。

- アプリのサーバーDB（復号可能な形式）。
- [[設定ファイル言語|設定ファイル]]や環境[[AI激動期における「定数」思考|変数]]。
- セッション[[Cookie]]の使い回し。

これは技術的に見ると、**鍵の原本を他人に預ける**行為である。

---

### 実際に起きた事故の本質

表面的な事故は以下のように見える。

- DB流出によるパスワード漏洩。
- なりすまし投稿・DM送信。
- バグによるデータ破壊。

しかし本質的な問題は別にある。

- 誰が操作したのか分からない。
- どこまで許可したのか分からない。
- 特定のアプリだけを止められない。

つまり、**責任と権限の境界が消失していた**。

[[OAuth]]はこの崩壊を立て直すために生まれた。

---

## 2. [[OAuth2.0|OAuth]]の本質的な役割

[[OAuth]]はログイン方式ではない。

**第三者に対して、限定的な権限を委任するための認可（Authorization）の規格**である。

ここで明確に分離される。

- 本人確認（Authentication）→ サービス本体の責任。
- 何をさせてよいか（Authorization）→ ユーザーの意思。
- 実際の操作 → 第三者アプリ。

この三点を技術的に強制するのが[[OAuth]]である。

---

## 3. [[OAuth2.0|OAuth 2.0]] 認可コードフローの全体像

```
① ユーザー
   「このアプリを使いたい」
        ↓
② 第三者アプリ
   ユーザーをサービス本体へ誘導
        ↓
③ サービス本体
   本人確認（公式ログイン画面）
        ↓
④ ユーザー
   権限を承認（scope）
        ↓
⑤ サービス本体
   認可コードを発行
        ↓
⑥ 第三者アプリ（サーバー）
   認可コードをトークンと交換
        ↓
⑦ 第三者アプリ
   トークンでAPIを呼ぶ
```

この流れは、**人間の意思決定と機械的な権限発行を分離する**ための構造になっている。

---

## 4. なぜ「認可コード」を必ず挟むのか

### ブラウザは危険地帯である

ブラウザは以下の理由で信用できない。

- [[URI・URL・URN|URL]]に情報が露出する。
- JavaScriptが自由に動く。
- 拡張機能が介入できる。
- 履歴・ログ・Refererに残る。

ここに価値のある情報を置くのは設計ミスになる。

---

### トークンを直接渡した場合の破綻

```
https://app.example.com/callback
  ?access_token=ABC
```

この瞬間、アクセストークンは以下に露出する。

- ブラウザ履歴。
- JS（[[基礎 Part 11 XSSとsanitize|XSS]]含む）。
- 拡張機能。
- ログ。

アクセストークンは**実際にAPIを実行できる権限そのもの**であり、盗まれた瞬間に被害が確定する。

---

### 認可コードというクッション

認可コードは以下の性質を持つ。

- 有効時間が極端に短い。
- 1回しか使えない。
- 単体では何もできない。

```
?code=AUTH_CODE
```

このコードを、サーバー同士の安全な通信で

```
AUTH_CODE
+ client_id
+ client_secret
```

と引き換えにして初めてトークンが発行される。

つまり、**価値のあるものは裏側でしか生まれない**。

---

## 5. トークン設計と[[寿命と老化|寿命]]の思想（どこで・どう渡るか）

[[OAuth]] 2.0は「価値の高いものほど危険な経路を通さない」「盗まれる前提で[[寿命と老化|寿命]]と使い道を[[基礎 Part 13 分割代入|分割]]する」という思想で設計される。

| 種類         | 役割                | どこで・どう渡るか（通信経路）                                            | 典型的な渡し方（HTTPの形）                                                         | どこに保存されがちか（実務）                               | なぜこの[[寿命と老化                                             | 寿命]]か                               |
| ---------- | ----------------- | ---------------------------------------------------------- | ----------------------------------------------------------------------- | -------------------------------------------- | ------------------------------------------------------- | ----------------------------------- |
| 認可コード      | 引換券（トークン発行の引き金）   | **ブラウザ経由**でサービス本体→第三者アプリのリダイレクト先へ渡る（表の世界）                  | `GET /callback?code=...&state=...`（[[URI・URL・URN                        | URL]]クエリ）                                    | 保存しない（受け取ったら即交換。ログに残さない）                                | ブラウザ経由は漏洩し得るため、盗まれても価値が低い短命・使い捨てにする |
| アクセストークン   | API実行（実働の鍵）       | **サーバー間**でサービス本体→第三者アプリに渡る（裏の世界）。API呼び出し時に第三者アプリ→サービス本体へ提示 | トークン取得：`POST /token` への応答（JSON）／API呼び出し：`Authorization: Bearer <token>` | サーバー側メモリ/キャッシュ、サーバー側DB（必要最小限）。クライアント露出は極力避ける | 盗まれる前提で被害を限定するため短命にする（短命にできるのは更新手段があるため）                |                                     |
| リフレッシュトークン | 再発行（アクセストークン更新の鍵） | **サーバー間**でサービス本体→第三者アプリに渡る（裏の世界）。更新時に第三者アプリ→サービス本体へ提示      | 取得：`POST /token` の応答（JSON）／更新：`POST /token`（`grant_type=refresh_token`） | 原則サーバー側DBで暗号化保管。厳格なアクセス制御。ローテーション運用が前提       | UX維持のため長命だが、盗まれると継続被害になるため「用途を限定し、管理を最も厳しくする」ことでバランスを取る |                                     |

[[寿命と老化|寿命]]はセキュリティリスク（盗まれる確率×被害）とUX（再ログイン頻度）の妥協点で決まる。危険な経路（ブラウザ）に露出するものは価値を下げ、価値の高いものは裏側（サーバー間）だけで授受・利用されるように設計する。

---

## 6. 認可コードが切れた場合

- 再利用不可。
- 延長不可。
- 再発行不可。

理由：認可コードは**ユーザーの意思確認の証跡**だからである。

切れた場合は、再度ユーザーの承認が必要になる。

---

## 7. アクセストークンが切れた場合

- リフレッシュトークンを使用する。
- ユーザー操作は不要。
- [[ITと不完全さに惹かれる理由|完全]]に裏側の処理。

```
[Refresh Token]
      ↓
[New Access Token]
```

これはUXを壊さずに短命トークンを成立させるための仕組みである。

---

## 8. リフレッシュトークンが盗まれたら何が起きるか

### 何が危険か

- 攻撃者は何度でもアクセストークンを生成できる。
- 被害が長期間継続する可能性がある。

つまり、リフレッシュトークンは**権限そのものではなく、権限を生み出す源泉**である。

---

### [[OAuth2.0|OAuth]]が前提としている考え方

[[OAuth]]は次を前提に設計されている。

- トークンは盗まれる。
- 完璧な防御は不可能。

そのため、被害を最小化する仕組みを重ねる。

---

### 主な対策と理由

1. **ローテーション**
   - 再利用検知を可能にする。
   - 同時使用を攻撃として判定できる。

2. **有効期限**
   - 長期潜伏を防ぐ。

3. **利用元制限**
   - 横流し耐性を持たせる。

4. **[[基礎 Part 9ブロックとブロックスコープ|scope]]最小化**
   - 最悪時の被害を限定する。

5. **明示的失効**
   - ユーザー主権を守る。

---

## 9. 保存場所の実務的な結論

- クライアント側保存は基本的に危険である。
- サーバー側での集中管理が前提である。
- 暗号化とアクセス制御は必須である。

理由：攻撃者モデルが「ユーザー端末侵害」を含むためである。

---

## 10. 最終まとめ（設計思想）

[[OAuth]] 2.0は、

- ブラウザを信用しない。
- 盗まれる前提で設計する。
- 人間の意思と機械の権限を分離する。

ことで、三者モデルを現実世界で成立させるための規格である。
