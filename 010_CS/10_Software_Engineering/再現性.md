---
base: "[[CS.Software_Engineering.base]]"
作成者: Katsubo Katsubo
カテゴリー:
  - CS
作成日時: 2026-02-08T12:00:00
aliases: [再現性, reproducibility, 環境の再現性]
---
# [[再現性]]

## [[再現性]]とは何か

ITにおける再現性とは、「誰が・いつ・どこで実行しても、同じ結果が得られる状態」を指す。

* 開発者が変わっても動く
* 時間が経っても同じ挙動をする
* 環境が変わっても結果が一致する

再現性は、品質・スピード・信頼性のすべてに直結する基礎概念である。

---

## 再現性が重要な理由

再現性が低いと、以下のような問題が頻発する。

* 「自分の環境では動く」
* 新人の環境構築に毎回時間がかかる
* 本番だけで不具合が発生する
* バグが再現できず修正できない

これらはすべて「環境や状態が揃っていない」ことが原因である。

---

## 再現性を壊す主な原因

1. 人の記憶や経験に依存している
2. 手作業による設定が多い
3. 現在の状態がコードやファイルとして残っていない

再現性を高めるには、これらを排除する必要がある。

---

## 再現性を支えるレイヤー構造

ITシステムは複数の層（レイヤー）から成り立っている。再現性は下位レイヤーから順に固める。

```
人
 └ 手順・ドキュメント
    └ OS
       └ ミドルウェア
          └ 言語・ランタイム
             └ 依存関係
                └ アプリケーション
```

上の層ほど変化しやすく、下の層ほど安定している。

---

## 各レイヤーと再現性の担保方法

### 人（例外レイヤー）

* 記憶・経験・勘に依存し、決定論的に固定できない
* 再現性の観点では「変動要因（ノイズ）」であり、スタックの土台というよりスタックの外側にある
* 対策：人の判断や手作業を前提にせず、コードと自動化で置き換える（例：ワンコマンドセットアップ、CIでの自動検証、手順のチェックリスト化）

### 手順・ドキュメント（橋渡し）

* READMEや手順書、Runbook
* 人の作業を補助するが、時間とともに陳腐化する
* 位置づけ：コード化・自動化へ移行するまでの橋渡し。最終的には「ドキュメントどおりに手で頑張る」状態を減らす

### OS

* Windows / macOS / Linux
* 対策：OSを揃える、DockerやWSLを利用する

### ミドルウェア

* DB、Redis、Webサーバなど
* 対策：Docker、docker-compose、設定ファイルのコード管理

### 言語・ランタイム

* Node.js、Pythonなど
* 対策：nvm、pyenv、asdf、バージョン固定ファイル

例：

```
# .nvmrc
20.11.1
```

### 依存関係

* npm、pipなどのライブラリ
* 対策：lockファイルを必ず管理する

例：

* package-lock.json
* poetry.lock

### アプリケーション

* 自分たちが書いたコード
* 下位レイヤーが安定して初めて品質が担保される

---

## 再現性を高める代表的な技術

### パッケージ管理

* winget / brew / scoop / apt
* 開発端末の道具を揃える

### Docker

* ミドルウェアや実行環境をまとめて固定する

例：

```
docker compose up
```

### CI

* 再現性が壊れていないかを自動で検証する

例：

* npm ci
* npm test

### IaC（Infrastructure as Code）

* Terraform、CDK、CloudFormation
* インフラ構成そのものを再現可能にする

---

## 現場でのスタート手順（再現性を作る順番）

再現性は一気に完成させるものではなく、段階的に積み上げる。以下はアプリ開発の現場で実践的なスタート順である。

### Step 0：前提を決める

最初に最小限の前提を決める。

* 主要OS（Windows / macOS / Linux、Windowsの場合はWSLを使うか）
* 使用言語とバージョン（例：Node.js 20、Python 3.11）
* 必要な外部要素の最小構成（DBが必要か、Redisが必要か）

ここが曖昧だと、以降すべてが揺れる。

### Step 1：端末の再現（パッケージ管理）

目的は、誰のPCでも同じ開発道具を揃えること。

* Windows：winget / scoop
* macOS：Homebrew
* Linux：ディストリビューションに依存（例：Ubuntu/Debian系は apt、RHEL系は dnf/yum、Arch系は pacman）

例（Windows）：

* Git
* VS Code
* Docker Desktop

開発に必要なものだけに絞ることが重要である。

### Step 2：言語・ランタイムを固定する

言語のバージョン差は再現性を壊しやすい。

* nvm / pyenv / asdf を利用
* バージョン指定ファイルをリポジトリに含める

例：

```
20.11.1
```

### Step 3：依存関係を固定する

* package-lock.json / poetry.lock を必ずコミットする
* CIでも同じインストール手順を使う

これにより「昨日は動いた」問題を防ぐ。

### Step 4：1コマンドで起動できる状態を作る

* npm run dev
* make dev

新人でも迷わず起動できることが目標である。READMEはこの手順を補足する程度でよい。

### Step 5：Dockerを導入する（必要になったら）

Dockerは最初から必須ではない。以下が導入の目安となる。

* DBやRedisなどの外部サービスが必要になった
* 環境差による不具合が出始めた
* 新人オンボードに時間がかかる

この段階で docker compose によりミドルウェア層を固定すると事故が減る。

### Step 6：CIで再現性を監視する

CIは再現性が壊れていないかを検証する仕組みである。

* npm ci
* テスト、Lint、ビルド

人が気づく前に差分を検出できる。

### Step 7：IaCを導入する（本番が見えたら）

以下のタイミングでIaCを必ず導入する。

* AWSなどに本番リソースを作り始めた
* 環境が複数（dev / stg / prod）に分かれた
* 手作業でのインフラ構築が増えた

TerraformやCDKにより、インフラそのものを再現可能にする。

---

## 再現性の成熟度レベル

```
Lv1: ドキュメントのみ
Lv2: スクリプト化
Lv3: 宣言的設定（Docker、設定ファイル）
Lv4: CI/CDとIaCによる完全自動化
```

理想は「Gitをcloneして1コマンドで環境が立ち上がる」状態である。

---

## 実務での最重要原則

* 再現性は最初に作る
* 下位レイヤーから固める
* 人に期待しない
* 状態は必ずコードで残す

再現性は派手ではないが、チーム開発と長期運用を支える最重要基盤である。
